/*! shortId.js
 https://github.com/dylang/shortid
 Copyright (c) Dylan Greene
 License: MIT +no-false-attribs License
*/
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.shortId=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
var random = _dereq_('./random');

var ORIGINAL = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-';
var alphabet;
var previousSeed;

var shuffled;

function reset() {
    shuffled = false;
}

function setCharacters(_alphabet_) {

    if (!_alphabet_) {
        if (alphabet !== ORIGINAL) {
            alphabet = ORIGINAL;
            reset();
        }
        return;
    }

    if (_alphabet_ === alphabet) {
        return;
    }


    if (_alphabet_.length !== ORIGINAL.length) {
        throw new Error('Custom alphabet for shortId must be ' + ORIGINAL.length + ' unique characters. You submitted ' + _alphabet_.length + ' characters: ' + _alphabet_);
    }

    var unique = _alphabet_.split('').filter(function(item, ind, arr){
       return ind !== arr.lastIndexOf(item);
    });

    if (unique.length) {
        throw new Error('Custom alphabet for shortId must be ' + ORIGINAL.length + ' unique characters. These characters were not unique: ' + unique.join(', '));
    }

    alphabet = _alphabet_;
    reset();
}

function setSeed(seed) {
    random.seed(seed);
    if (previousSeed !== seed) {
        reset();
        previousSeed = seed;
    }
}

function shuffle() {
    if (!alphabet) {
        setCharacters(ORIGINAL);
    }

    var sourceArray = alphabet.split('');
    var targetArray = [];
    var r = random();
    var characterIndex;
    while (sourceArray.length > 0) {
        r = random();
        characterIndex = Math.floor(r * sourceArray.length);
        targetArray.push(sourceArray.splice(characterIndex, 1)[0]);
    }
    return targetArray.join('');
}

function getShuffled() {
    if (shuffled) {
        return shuffled;
    }
    shuffled = shuffle();
    return shuffled;
}

/**
 * lookup shuffled letter
 * @param index
 * @returns {string}
 */
function lookup(index) {
    var alphabetShuffled = getShuffled();
    return alphabetShuffled[index];
}

module.exports = {
    characters: setCharacters,
    seed:       setSeed,
    lookup:     lookup,
    shuffled:   getShuffled
};

},{"./random":3}],2:[function(_dereq_,module,exports){
var randomNum;

// Browser test
var hasCrypto = true;
if(typeof window !== 'undefined') {
    hasCrypto = false;
}
else {
    try {
        _dereq_.resolve('crypto');
    } catch(e) {
        hasCrypto = false;
    }
}

// Load the appropriate function
if(!hasCrypto) { // Browser or other JS runtimes without crypto
    // Test if Web Crypto API is available
    if( typeof window !== 'undefined' && ((window.crypto && window.crypto.getRandomValues) || (window.msCrypto && window.msCrypto.getRandomValues)) ) {
        var cryptoObj = window.crypto || window.msCrypto; // IE 11 uses window.msCrypto
        randomNum = function() {
            var dest = new Uint8Array(1);
            cryptoObj.getRandomValues(dest);
            return dest[0] & 0x30;
        };
    }
    else {
        // Fallback to Math.random(), which is not cryptographically-secure
        randomNum = function() {
            return Math.floor(Math.random() * 256) & 0x30;
        };
    }
}
else { // Node.js
    var randomBytes = _dereq_('crypto').randomBytes;
    randomNum = function() {
        return randomBytes(1)[0] & 0x30;
    };
}

function encode(lookup, number) {
    var loopCounter = 0;
    var done;

    var str = '';

    while (!done) {
        str = str + lookup( ( (number >> (4 * loopCounter)) & 0x0f ) | randomNum() );
        done = number < (Math.pow(16, loopCounter + 1 )  );
        loopCounter++;
    }
    return str;
}

module.exports = encode;

},{"crypto":"crypto"}],3:[function(_dereq_,module,exports){

// Found this seed-based random generator somewhere
// Based on The Central Randomizer 1.3 (C) 1997 by Paul Houle (houle@msc.cornell.edu)

/**
 * return a random number based on a seed
 * @param seed
 * @returns {number}
 */

var seed = 1;

module.exports = function random() {
    seed = (seed * 9301 + 49297) % 233280;
    return seed/(233280.0);
};

module.exports.seed = function (_seed_) {
    seed = _seed_;
};
},{}],4:[function(_dereq_,module,exports){
/*
 * Short Id
 * by Dylan Greene
 */

var alphabet = _dereq_('./alphabet'),
    encode = _dereq_('./encode');

// Ignore all milliseconds before a certain time to reduce the size of the date entropy without sacrificing uniqueness.
// This number should be updated every year or so to keep the generated id short.
// To regenerate `new Date() - 0` and bump the version. Always bump the version!
var REDUCE_TIME = 1415358116771;

// don't change unless we change the algos or REDUCE_TIME
// must be an integer and less than 16
var version = 4;

// if you are using cluster or multiple servers use this to make each instance
// has a unique value for worker
var clusterWorkerId = parseInt(0 || 0, 10);

// Counter is used when shortId is called multiple times in one second.
var counter;

// Remember the last time shortId was called in case counter is needed.
var previousSeconds;

/**
 * Generate unique id
 * Returns string id
 */
function generate() {

    var str = '';

    var seconds = Math.floor((Date.now() - REDUCE_TIME) * 0.001);

    if (seconds === previousSeconds) {
        counter++;
    } else {
        counter = 0;
        previousSeconds = seconds;
    }

    str = str + encode(alphabet.lookup, version);
    str = str + encode(alphabet.lookup, clusterWorkerId);
    if (counter > 0) {
        str = str + encode(alphabet.lookup, counter);
    }
    str = str + encode(alphabet.lookup, seconds);

    return str;
}


/**
 * Set the seed.
 * Highly recommended if you don't want people to try to figure out your id schema.
 * exposed as ShortId.seed(int)
 * @param seed Integer value to seed the random alphabet.  ALWAYS USE THE SAME SEED or you might get overlaps.
 */
function seed(seedValue) {
    alphabet.seed(seedValue);
    return module.exports;
}

/**
 * Set the cluster worker or machine id
 * exposed as ShortId.worker(int)
 * @param workerId worker must be positive integer.  Number less than 16 is recommended.
 * returns ShortId module so it can be chained.
 */
function worker(workerId) {
    clusterWorkerId = workerId;
    return module.exports;
}

/**
 *
 * returns the shuffled alphabet
 */
function characters(newCharacters) {
    if (newCharacters !== undefined) {
        alphabet.characters(newCharacters);
    }

    return alphabet.shuffled();
}

/**
 * Decode the id to get the version and worker
 * Mainly for debugging and testing.
 * @param id - the ShortId-generated id.
 */
function decode(id) {
    var alphabet = characters();
    return {
        version: alphabet.indexOf(id.substr(0, 1)) & 0x0f,
        worker: alphabet.indexOf(id.substr(1, 1)) & 0x0f
    };
}

// Export all other functions as properties of the generate function
generate.generate = generate;
generate.seed = seed;
generate.worker = worker;
generate.characters = characters;
generate.decode = decode;

// Export generate
module.exports = generate;

},{"./alphabet":1,"./encode":2}]},{},[4])(4)
});